<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Richarlison Horizon - Turbo Edition</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: sans-serif; }
        #ui { position: absolute; width: 100%; height: 100%; pointer-events: none; }
        #loading-screen {
            position: absolute; width: 100%; height: 100%; background: #000;
            color: #0f0; display: flex; flex-direction: column; 
            align-items: center; justify-content: center; z-index: 100;
        }
        .btn { 
            margin-top: 20px; padding: 15px 30px; background: #0f0; 
            border: none; font-weight: bold; cursor: pointer; border-radius: 8px; pointer-events: all;
        }
        #speedo {
            position: absolute; bottom: 30px; right: 30px; color: white;
            font-size: 35px; font-weight: 900; font-style: italic; 
            text-shadow: 3px 3px 0px #ff00ff; font-family: 'Arial Black', sans-serif;
        }
        #turbo-bar {
            position: absolute; bottom: 80px; right: 30px; width: 150px; height: 10px;
            background: rgba(255,255,255,0.2); border: 2px solid #0ff;
        }
        #turbo-fill { width: 0%; height: 100%; background: #0ff; transition: width 0.1s; }
    </style>
</head>
<body>

    <div id="loading-screen">
        <div id="status">INSTALANDO TURBO E SOM...</div>
        <button id="start-btn" class="btn" style="display:none" onclick="start()">DIRIGIR</button>
    </div>
    
    <div id="ui">
        <div id="speedo">0 KM/H</div>
        <div id="turbo-bar"><div id="turbo-fill"></div></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>

    <script>
        let scene, camera, renderer, car, city;
        let moveSpeed = 0, carRotation = 0, gameActive = false;
        
        // CONFIGURAÇÕES DE FÍSICA
        const stats = {
            accel: 0.05,
            turboAccel: 0.15,
            maxSpeed: 2.2,
            maxTurboSpeed: 5.0,
            maxReverse: -0.5,
            friction: 0.97
        };

        let camAngleH = 0, currentCamRotation = 0;
        const raycaster = new THREE.Raycaster();

        // SISTEMA DE SOM (WEB AUDIO API)
        let audioCtx, oscillator, gainNode;

        function initAudio() {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            oscillator = audioCtx.createOscillator();
            gainNode = audioCtx.createGain();
            oscillator.type = 'sawtooth'; 
            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            gainNode.gain.value = 0;
            oscillator.start();
        }

        function updateEngineSound() {
            if (!oscillator) return;
            let pitch = Math.abs(moveSpeed) * 40 + 60; // Frequência baseada na velocidade
            oscillator.frequency.setTargetAtTime(pitch, audioCtx.currentTime, 0.1);
            gainNode.gain.setTargetAtTime(gameActive ? 0.05 : 0, audioCtx.currentTime, 0.1);
        }

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a15);
            scene.fog = new THREE.FogExp2(0x0a0a15, 0.005);
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 4000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.outputEncoding = THREE.sRGBEncoding;
            document.body.appendChild(renderer.domElement);

            scene.add(new THREE.AmbientLight(0xffffff, 2.0));
            const loader = new THREE.GLTFLoader();

            loader.load('./city_at_night.glb', (gltf) => {
                city = gltf.scene;
                city.scale.set(5, 5, 5);
                scene.add(city);
                checkReady();
            });

            loader.load('./carro.glb', (gltf) => {
                car = gltf.scene;
                const bbox = new THREE.Box3().setFromObject(car);
                const size = new THREE.Vector3();
                bbox.getSize(size);
                car.scale.setScalar(10 / size.z); 
                scene.add(car);
                checkReady();
            });
        }

        let items = 0;
        function checkReady() { if(++items >= 2) document.getElementById('start-btn').style.display = "block"; }

        function start() {
            initAudio();
            document.getElementById('loading-screen').style.display = "none";
            gameActive = true;
            animate();
        }

        function updatePhysics() {
            const gps = navigator.getGamepads();
            const gp = gps[0] || gps[1];

            if (gp && gameActive && car) {
                let jY = gp.axes[1]; 
                let jX = gp.axes[0]; 
                let cX = gp.axes[2]; 
                let btnL1 = gp.buttons[4].pressed; // L1 para Turbo

                // LOGICA TURBO L1
                let currentMax = btnL1 ? stats.maxTurboSpeed : stats.maxSpeed;
                let currentAccel = btnL1 ? stats.turboAccel : stats.accel;
                
                // UI TURBO
                document.getElementById('turbo-fill').style.width = btnL1 ? "100%" : "0%";

                // MOVIMENTO (FRENTE / RÉ)
                if (Math.abs(jY) > 0.1) {
                    moveSpeed -= jY * currentAccel;
                }
                
                moveSpeed *= stats.friction;

                // LIMITES DE VELOCIDADE (RÉ É MAIS LENTA)
                if (moveSpeed > currentMax) moveSpeed = currentMax;
                if (moveSpeed < stats.maxReverse) moveSpeed = stats.maxReverse;

                // DIREÇÃO
                if (Math.abs(moveSpeed) > 0.05) {
                    let steerFactor = btnL1 ? 0.03 : 0.05; // Mais difícil virar no turbo
                    carRotation -= jX * steerFactor * (moveSpeed > 0 ? 1 : -1);
                }

                // COLISÃO INTELIGENTE
                const headDir = new THREE.Vector3(Math.sin(carRotation), 0, Math.cos(carRotation)).normalize();
                raycaster.set(car.position, headDir);
                const intersects = raycaster.intersectObject(city, true);
                if (intersects.length > 0) {
                    if (intersects[0].distance < 3.8 && intersects[0].point.y > 0.7 && moveSpeed > 0.1) {
                        moveSpeed = -0.2; // Bateu na parede
                    }
                }

                car.rotation.y = carRotation;
                car.position.x += Math.sin(carRotation) * moveSpeed;
                car.position.z += Math.cos(carRotation) * moveSpeed;

                document.getElementById('speedo').innerText = Math.abs(Math.round(moveSpeed * 100)) + " KM/H";
                if (Math.abs(cX) > 0.1) camAngleH += cX * 0.08;
                
                updateEngineSound();
            }

            if (car) {
                currentCamRotation += (carRotation - currentCamRotation) * 0.08;
                
                // FOV DINÂMICO (Efeito de velocidade do Turbo)
                let targetFOV = 70 + (Math.abs(moveSpeed) * 10);
                camera.fov += (targetFOV - camera.fov) * 0.1;
                camera.updateProjectionMatrix();

                const dist = 22 + (Math.abs(moveSpeed) * 4);
                const finalRot = currentCamRotation + camAngleH;

                camera.position.x = car.position.x - Math.sin(finalRot) * dist;
                camera.position.z = car.position.z - Math.cos(finalRot) * dist;
                camera.position.y = car.position.y + 7 + (Math.abs(moveSpeed) * 0.5);
                camera.lookAt(car.position.x, car.position.y + 3, car.position.z);
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            updatePhysics();
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        init();
    </script>
</body>
</html>
