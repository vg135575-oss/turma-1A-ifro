<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Richarlison 3D Free Roam</title>
    <style>
        body { margin: 0; overflow: hidden; background: #050510; font-family: sans-serif; }
        #loading-screen {
            position: absolute; width: 100%; height: 100%; background: #000;
            color: #0f0; display: flex; flex-direction: column; 
            align-items: center; justify-content: center; z-index: 100;
        }
        .btn { 
            margin-top: 20px; padding: 15px 30px; background: #0f0; 
            border: none; font-weight: bold; cursor: pointer; pointer-events: all;
        }
    </style>
</head>
<body>

    <div id="loading-screen">
        <div id="status">CARREGANDO MUNDO 3D...</div>
        <div id="error-log" style="color: red; font-size: 12px; margin-top: 10px;"></div>
        <button id="start-btn" class="btn" style="display:none" onclick="start()">INICIAR EXPLORAÇÃO</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>

    <script>
        let scene, camera, renderer, car, city;
        let moveSpeed = 0, maxSpeed = 0.5, acceleration = 0.01, friction = 0.95;
        let carRotation = 0;
        let gameActive = false;
        
        // Controle de Câmera
        let cameraAngleH = 0;
        let cameraAngleV = 0.5;

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x020205);
            scene.fog = new THREE.FogExp2(0x020205, 0.01);

            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            const light = new THREE.HemisphereLight(0xffffff, 0x000000, 1);
            scene.add(light);
            
            const spotLight = new THREE.PointLight(0x00ffff, 2, 50);
            scene.add(spotLight);

            // Chão de emergência (Caso a cidade suma)
            const grid = new THREE.GridHelper(1000, 100, 0x444444, 0x222222);
            scene.add(grid);

            const loader = new THREE.GLTFLoader();

            // Carregar Cidade
            // --- CARREGAMENTO DA CIDADE (GIGANTE) ---
            loader.load('./city_at_night.glb', (gltf) => {
                city = gltf.scene;
                // Aumentei para 5, se ainda estiver pequena, suba para 10
                city.scale.set(5, 5, 5); 
                scene.add(city);
                log("Cidade carregada e ampliada.");
                checkReady();
            }, undefined, (e) => {
                log("Erro na cidade, usando grid reserva.", true);
                checkReady();
            });

            // --- CARREGAMENTO DO CARRO (FORÇANDO TAMANHO) ---
            loader.load('./carro.glb', (gltf) => {
                car = gltf.scene;
                
                // 1. Resetar escala para garantir
                car.scale.set(1, 1, 1);
                
                // 2. Calcular o tamanho real do modelo carregado
                const bbox = new THREE.Box3().setFromObject(car);
                const size = new THREE.Vector3();
                bbox.getSize(size);
                
                // 3. Ajuste de escala baseado no tamanho real
                // Se o carro for microscópico, isso vai multiplicá-lo até ele ficar visível
                const targetSize = 4; // Queremos que o carro tenha 4 metros de comprimento
                const scaleFactor = targetSize / size.z;
                car.scale.setScalar(scaleFactor);
                
                // 4. Centralizar o "pé" do carro no chão
                car.position.y = 0; 
                
                scene.add(car);
                log("Carro ajustado para escala real.");
                checkReady();
            }, undefined, (e) => {
                log("Erro no carro.glb, usando cubo reserva.", true);
                // Cubo reserva bem visível
                const geo = new THREE.BoxGeometry(2, 1, 4);
                car = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({color: 0xff0000}));
                scene.add(car);
                checkReady();
            });
        }

        function checkReady() {
            document.getElementById('start-btn').style.display = "block";
        }

        function start() {
            document.getElementById('loading-screen').style.display = "none";
            gameActive = true;
            animate();
        }

        function updatePhysics() {
            const gamepads = navigator.getGamepads();
            const gp = gamepads[0] || gamepads[1];

            if (gp && gameActive) {
                // Analógico Esquerdo - Eixo 1 (Vertical = Acelerar), Eixo 0 (Horizontal = Virar)
                let joyY = gp.axes[1]; 
                let joyX = gp.axes[0];
                
                // Analógico Direito - Eixo 2 e 3 (Câmera)
                let camX = gp.axes[2];
                let camY = gp.axes[3];

                // Movimento do Carro
                if (Math.abs(joyY) > 0.1) {
                    moveSpeed -= joyY * acceleration;
                }
                
                // Atrito Natural
                moveSpeed *= friction;

                // Virar o carro (apenas se estiver andando)
                if (Math.abs(moveSpeed) > 0.01) {
                    carRotation -= joyX * 0.05 * (moveSpeed > 0 ? 1 : -1);
                }

                // Aplicar Rotação e Translação
                car.rotation.y = carRotation;
                car.position.x += Math.sin(carRotation) * moveSpeed;
                car.position.z += Math.cos(carRotation) * moveSpeed;

                // Controle de Câmera (Orbitar)
                if (Math.abs(camX) > 0.1) cameraAngleH += camX * 0.05;
                if (Math.abs(camY) > 0.1) cameraAngleV = Math.max(0.1, Math.min(1.2, cameraAngleV + camY * 0.05));
            }

            // Posicionar Câmera atrás do carro com base no ângulo orbital
            if (car) {
                const dist = 8;
                camera.position.x = car.position.x - Math.sin(carRotation + cameraAngleH) * dist;
                camera.position.z = car.position.z - Math.cos(carRotation + cameraAngleH) * dist;
                camera.position.y = car.position.y + (cameraAngleV * 5);
                camera.lookAt(car.position.x, car.position.y + 1, car.position.z);
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            updatePhysics();
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        init();
    </script>
</body>
</html>
