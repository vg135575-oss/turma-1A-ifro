<!doctype html>

<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Richarlison - Corrida Infinita (Three.js)</title>
  <style>
    html, body { height:100%; margin:0; background:#000; -webkit-touch-callout:none; -webkit-user-select:none; -ms-user-select:none; user-select:none; }
    #container { width:100%; height:100%; overflow:hidden; position:relative; }
    canvas { display:block; }
    /* Simple on-screen HUD for debugging */
    #hud {
      position:absolute; left:10px; top:10px; color:#fff; font-family:system-ui, sans-serif; z-index:10;
      background:rgba(0,0,0,0.25); padding:6px 8px; border-radius:8px; font-size:14px;
    }
    #startBtn { position:absolute; right:10px; top:10px; z-index:10; }
  </style>
</head>
<body>
  <div id="container">
    <div id="hud">Toque esquerda/direita para mover</div>
  </div>  <!-- Three.js e GLTFLoader (versões CDN compatíveis com uso direto no navegador) -->  <script src="https://unpkg.com/three@0.154.0/build/three.min.js"></script>  <script src="https://unpkg.com/three@0.154.0/examples/js/loaders/GLTFLoader.js"></script>  <script>
    // Configurações principais
    const container = document.getElementById('container');
    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x000000, 10, 80);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
    renderer.setPixelRatio(window.devicePixelRatio ? Math.min(window.devicePixelRatio, 2) : 1);
    renderer.setSize(window.innerWidth, window.innerHeight);
    container.appendChild(renderer.domElement);

    // Câmera atrás do carro
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 200);
    camera.position.set(0, 3.5, 8);

    // Iluminação simples
    const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 0.8);
    hemi.position.set(0, 20, 0);
    scene.add(hemi);
    const dir = new THREE.DirectionalLight(0xffffff, 0.8);
    dir.position.set(-3, 10, 5);
    scene.add(dir);

    // Chão - estrada com textura animada (usando canvas)
    const roadCanvas = document.createElement('canvas');
    roadCanvas.width = 512; roadCanvas.height = 512;
    const ctx = roadCanvas.getContext('2d');

    function drawRoadTexture() {
      ctx.fillStyle = '#333';
      ctx.fillRect(0,0,roadCanvas.width, roadCanvas.height);
      // faixas centrais
      ctx.fillStyle = '#f5f5f5';
      const stripeW = 40;
      const gap = 60;
      ctx.fillRect(roadCanvas.width/2 - 6, 0, 12, roadCanvas.height);
      // desenha listras interrompidas
      ctx.fillStyle = '#ffd';
      for(let y = -roadCanvas.height; y < roadCanvas.height*2; y += gap) {
        ctx.fillRect(roadCanvas.width/2 - 4, y + 10, 8, stripeW);
      }
    }
    drawRoadTexture();

    const roadTexture = new THREE.CanvasTexture(roadCanvas);
    roadTexture.wrapS = roadTexture.wrapT = THREE.RepeatWrapping;
    roadTexture.repeat.set(1, 20);

    const roadGeom = new THREE.PlaneGeometry(6, 200, 1, 1);
    const roadMat = new THREE.MeshLambertMaterial({ map: roadTexture });
    const roadMesh = new THREE.Mesh(roadGeom, roadMat);
    roadMesh.rotation.x = -Math.PI/2;
    roadMesh.position.y = 0;
    roadMesh.receiveShadow = true;
    scene.add(roadMesh);

    // Bordas da estrada (relva)
    const leftGrass = new THREE.Mesh(new THREE.PlaneGeometry(40, 200), new THREE.MeshLambertMaterial({ color: 0x1f7a1f }));
    leftGrass.rotation.x = -Math.PI/2; leftGrass.position.set(-8, 0, 0);
    scene.add(leftGrass);
    const rightGrass = leftGrass.clone(); rightGrass.position.set(8, 0, 0); scene.add(rightGrass);

    // Carro - será carregado do arquivo carro.glb (mesma pasta)
    let car = new THREE.Object3D();
    let carLoaded = false;
    const loader = new THREE.GLTFLoader();

    loader.load('[carro.glb]', function(gltf) {
      car = gltf.scene;
      // normalizar tamanho e posição do carro
      car.traverse((c) => { if(c.isMesh) { c.castShadow = true; c.receiveShadow = true; } });
      // centralizar
      const box = new THREE.Box3().setFromObject(car);
      const size = new THREE.Vector3(); box.getSize(size);
      const maxDim = Math.max(size.x, size.y, size.z);
      const scale = 1.5 / maxDim;
      car.scale.setScalar(scale);
      // posiciona o carro em cima do chão
      car.position.set(0, 0.15, 0);

      scene.add(car);
      carLoaded = true;
    }, undefined, function(err){
      console.error('Erro ao carregar carro.glb', err);
      alert('Erro: não foi possível carregar o modelo carro.glb. Verifique se o arquivo está na mesma pasta.');
    });

    // Jogabilidade
    const laneX = [-2, 0, 2]; // 3 pistas: esquerda, centro, direita
    let currentLane = 1; // começa no centro

    const carState = {
      x: laneX[currentLane],
      y: 0,
      z: 0,
      targetX: laneX[currentLane],
      speed: 12 // velocidade dos objetos vindo na direção do jogador (unidades/segundo)
    };

    // Obstáculos
    const obstacles = [];
    const obstaclePool = [];

    function createObstacle() {
      // Simples: cubo ou esfera com materiais distintos
      const isSphere = Math.random() > 0.5;
      let mesh;
      if(isSphere) {
        mesh = new THREE.Mesh(new THREE.SphereGeometry(0.5, 12, 12), new THREE.MeshStandardMaterial({ color: 0xff5555 }));
      } else {
        mesh = new THREE.Mesh(new THREE.BoxGeometry(1,1,1), new THREE.MeshStandardMaterial({ color: 0x5555ff }));
      }
      mesh.castShadow = true;
      mesh.receiveShadow = true;

      // posiciona inicialmente à frente (z positivo é para trás da câmera, team coordinate uses camera at z=8 looking towards negative z)
      const lane = Math.floor(Math.random()*3);
      mesh.position.set(laneX[lane], 0.5, -60 + Math.random()*20); // spawn a distância

      scene.add(mesh);
      obstacles.push(mesh);
    }

    let spawnTimer = 0;
    const spawnInterval = 0.9; // segundos entre obstáculos (pode variar)

    // Toque / controle
    let touchLeft = false;
    let touchRight = false;

    function onPointerDown(e) {
      e.preventDefault();
      const x = (e.touches && e.touches[0]) ? e.touches[0].clientX : e.clientX;
      if(x < window.innerWidth/2) { touchLeft = true; }
      else { touchRight = true; }
    }
    function onPointerUp(e) {
      e.preventDefault();
      touchLeft = false; touchRight = false;
    }

    // adiciona listeners para toque e clique
    window.addEventListener('touchstart', onPointerDown, {passive:false});
    window.addEventListener('touchend', onPointerUp, {passive:false});
    window.addEventListener('mousedown', onPointerDown);
    window.addEventListener('mouseup', onPointerUp);

    // Detecta colisão simples usando Box3
    function checkCollision(objA, objB) {
      const boxA = new THREE.Box3().setFromObject(objA);
      const boxB = new THREE.Box3().setFromObject(objB);
      return boxA.intersectsBox(boxB);
    }

    // Reiniciar jogo
    function resetGame() {
      // remove obstáculos
      for(const o of obstacles) scene.remove(o);
      obstacles.length = 0;
      currentLane = 1; carState.x = laneX[currentLane]; carState.targetX = laneX[currentLane];
      if(car) car.position.set(0, 0.15, 0);
      spawnTimer = 0;
    }

    // Game Over
    function gameOver() {
      alert('Game Over');
      resetGame();
    }

    // Loop principal
    let lastTime = performance.now() / 1000;
    function animate() {
      const now = performance.now() / 1000;
      const dt = Math.min(0.05, now - lastTime);
      lastTime = now;

      // scroll da estrada
      roadTexture.offset.y -= carState.speed * dt / 6; // ajusta para parecer velocidade

      // spawn obstáculos
      spawnTimer += dt;
      if(spawnTimer > spawnInterval) {
        spawnTimer = 0;
        createObstacle();
      }

      // atualiza obstáculos: move na direção do jogador (incrementa z)
      for(let i = obstacles.length - 1; i >= 0; i--) {
        const o = obstacles[i];
        o.position.z += carState.speed * dt; // move em direção à câmera (carro fica em z=0)
        // se passou do jogador, remove
        if(o.position.z > 10) {
          scene.remove(o);
          obstacles.splice(i, 1);
        }
      }

      // input: se tocar esquerda/direita, altera target lane
      if(touchLeft) {
        if(currentLane > 0) { currentLane--; touchLeft = false; }
      } else if(touchRight) {
        if(currentLane < laneX.length - 1) { currentLane++; touchRight = false; }
      }

      carState.targetX = laneX[currentLane];
      // interpola a posição x do carro para ficar suave
      carState.x += (carState.targetX - carState.x) * Math.min(1, 12 * dt);

      // aplica posição no modelo quando carregado
      if(carLoaded) {
        car.position.x = carState.x;
        // mantem um leve bob na suspensão
        car.position.y = 0.15 + Math.sin(now*6)*0.02;
        // câmera segue atrás do carro
        const camTarget = new THREE.Vector3(car.position.x, car.position.y + 1.8, car.position.z - 6);
        camera.position.lerp(new THREE.Vector3(car.position.x, 3.5, car.position.z + 8), 0.12);
        camera.lookAt(new THREE.Vector3(car.position.x, car.position.y + 1.2, car.position.z - 4));
      }

      // colisões
      for(const o of obstacles) {
        if(carLoaded && checkCollision(car, o)) {
          gameOver();
          break;
        }
      }

      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }

    // Ajuste do tamanho da tela
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Inicia animação quando quiser (aqui inicia imediatamente)
    animate();

    // Pequena dica: também permito controle por teclado para testes em desktop
    window.addEventListener('keydown', (e) => {
      if(e.key === 'ArrowLeft' || e.key === 'a') {
        if(currentLane > 0) currentLane--;
      } else if(e.key === 'ArrowRight' || e.key === 'd') {
        if(currentLane < laneX.length - 1) currentLane++;
      }
    });
  </script></body>
</html>
