<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Richarlison Engine Focus - V2</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: sans-serif; }
        #loading-screen {
            position: absolute; width: 100%; height: 100%; background: #000;
            color: #0f0; display: flex; flex-direction: column; 
            align-items: center; justify-content: center; z-index: 100;
        }
        .btn { 
            margin-top: 20px; padding: 15px 40px; background: #0f0; 
            border: none; font-weight: bold; cursor: pointer; border-radius: 30px; 
            font-size: 18px; display: none;
        }
        #speedo {
            position: absolute; bottom: 40px; right: 40px; color: #fff;
            font-size: 45px; font-weight: 900; font-style: italic; 
            text-shadow: 4px 4px 0px #ff0055; font-family: 'Arial Black', sans-serif;
            pointer-events: none;
        }
    </style>
</head>
<body>

    <div id="loading-screen">
        <div id="status">SINTONIZANDO MOTOR E TURBO...</div>
        <button id="start-btn" class="btn" onclick="start()">LIGAR MÁQUINA</button>
    </div>
    <div id="speedo">0 KM/H</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>

    <script>
        let scene, camera, renderer, car, city;
        let moveSpeed = 0, carRotation = 0, gameActive = false;
        let rpm = 0;
        let wasAccelerating = false; // Para detectar quando solta o pé e o turbo espirrar
        
        // FÍSICA RECALIBRADA (PROGRESSIVA)
        const physics = {
            accel: 0.025,      // Aceleração mais lenta e realista
            maxSpeed: 3.5,     // Velocidade final maior
            friction: 0.985    // Menos atrito para manter a inércia
        };

        let audioCtx, engineSource, gainNode;
        let engineBuffer = null;

        function initAudio() {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            const url = 'https://raw.githubusercontent.com/nicolas-van/obsidian-racer/master/audio/engine.mp3';
            
            fetch(url)
                .then(res => res.arrayBuffer())
                .then(data => audioCtx.decodeAudioData(data))
                .then(buffer => {
                    engineBuffer = buffer;
                    document.getElementById('start-btn').style.display = "block";
                    document.getElementById('status').innerText = "MOTOR PRONTO";
                });
        }

        // Função para o espirro do Turbo (Som sintético realista)
        function playTurboSneeze() {
            if(!audioCtx) return;
            const noise = audioCtx.createBufferSource();
            const bufferSize = audioCtx.sampleRate * 0.5;
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
            
            noise.buffer = buffer;
            const filter = audioCtx.createBiquadFilter();
            filter.type = 'highpass';
            filter.frequency.value = 2000;
            
            const envelope = audioCtx.createGain();
            noise.connect(filter);
            filter.connect(envelope);
            envelope.connect(audioCtx.destination);
            
            envelope.gain.setValueAtTime(0.2, audioCtx.currentTime);
            envelope.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.4);
            
            noise.start();
            noise.stop(audioCtx.currentTime + 0.5);
        }

        function playEngine() {
            engineSource = audioCtx.createBufferSource();
            engineSource.buffer = engineBuffer;
            engineSource.loop = true;
            gainNode = audioCtx.createGain();
            engineSource.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            gainNode.gain.value = 0.3;
            engineSource.start(0);
        }

        function updateEngineSound(isAccelerating) {
            if (!engineSource) return;

            let targetRpm = Math.abs(moveSpeed) / physics.maxSpeed;
            if (isAccelerating) targetRpm += 0.2; // Aumenta o giro ao acelerar

            rpm += (targetRpm - rpm) * 0.05; // Subida suave do giro
            let pitch = 0.6 + (rpm * 1.8);
            
            if (rpm > 0.97) pitch += Math.sin(Date.now() * 0.06) * 0.12; // Corta giro

            engineSource.playbackRate.setTargetAtTime(pitch, audioCtx.currentTime, 0.05);
            gainNode.gain.setTargetAtTime(0.15 + (rpm * 0.5), audioCtx.currentTime, 0.1);

            // Se parou de acelerar bruscamente em alto giro: ESPIRRA!
            if (wasAccelerating && !isAccelerating && rpm > 0.5) {
                playTurboSneeze();
            }
            wasAccelerating = isAccelerating;
        }

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x050510);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 5000);
            scene.add(new THREE.AmbientLight(0xffffff, 1.5));

            const loader = new THREE.GLTFLoader();
            loader.load('./city_at_night.glb', (gltf) => { 
                city = gltf.scene; city.scale.set(5, 5, 5); scene.add(city); 
            });
            loader.load('./carro.glb', (gltf) => { 
                car = gltf.scene; 
                const bbox = new THREE.Box3().setFromObject(car);
                const size = new THREE.Vector3();
                bbox.getSize(size);
                car.scale.setScalar(12 / size.z); 
                scene.add(car); 
            });

            initAudio();
        }

        function start() {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            playEngine();
            document.getElementById('loading-screen').style.display = "none";
            gameActive = true;
            animate();
        }

        function updatePhysics() {
            const gps = navigator.getGamepads();
            const gp = gps[0] || gps[1];
            let accelerating = false;

            if (gp && gameActive && car) {
                let jY = gp.axes[1]; 
                let jX = gp.axes[0];

                if (jY < -0.1) { // Acelerar
                    moveSpeed += Math.abs(jY) * physics.accel;
                    accelerating = true;
                } else if (jY > 0.1) { // Ré
                    moveSpeed -= Math.abs(jY) * (physics.accel * 0.5);
                } else {
                    moveSpeed *= physics.friction;
                }

                if (moveSpeed > physics.maxSpeed) moveSpeed = physics.maxSpeed;
                if (moveSpeed < -0.8) moveSpeed = -0.8;

                if (Math.abs(moveSpeed) > 0.05) {
                    let steerSpeed = 0.04 * (1 - (Math.abs(moveSpeed) / (physics.maxSpeed * 1.5)));
                    carRotation -= jX * steerSpeed * (moveSpeed > 0 ? 1 : -1);
                }

                car.rotation.y = carRotation;
                car.position.x += Math.sin(carRotation) * moveSpeed;
                car.position.z += Math.cos(carRotation) * moveSpeed;

                document.getElementById('speedo').innerText = Math.abs(Math.round(moveSpeed * 110)) + " KM/H";
                updateEngineSound(accelerating);
            }

            if (car) {
                const dist = 25 + (Math.abs(moveSpeed) * 4);
                camera.position.x = car.position.x - Math.sin(carRotation) * dist;
                camera.position.z = car.position.z - Math.cos(carRotation) * dist;
                camera.position.y = car.position.y + 8;
                camera.lookAt(car.position.x, car.position.y + 2, car.position.z);
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            if(gameActive) updatePhysics();
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        init();
    </script>
</body>
</html>
