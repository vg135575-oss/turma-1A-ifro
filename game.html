<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>CYBER DRIFT 2077 | Neon Ultra</title>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;900&display=swap" rel="stylesheet">
  <style>
    body {
      margin: 0; padding: 0; overflow: hidden;
      background: #000; font-family: 'Orbitron', sans-serif;
    }
    #ui {
      position: absolute; top: 20px; left: 0; width: 100%;
      display: flex; justify-content: space-around;
      pointer-events: none; color: #0ff; text-shadow: 0 0 10px #0ff;
    }
    .stat { background: rgba(0,0,0,0.5); padding: 10px 20px; border: 1px solid #0ff; }
    
    #overlay {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0,0,0,0.8); display: flex; flex-direction: column;
      align-items: center; justify-content: center; z-index: 10;
    }
    h1 { color: #0ff; font-size: 4em; margin: 0; text-shadow: 0 0 30px #0ff; letter-spacing: 10px; }
    .btn {
      background: transparent; color: #0ff; border: 2px solid #0ff;
      padding: 15px 40px; font-size: 1.5em; cursor: pointer; margin-top: 30px;
      font-family: 'Orbitron'; transition: 0.3s;
    }
    .btn:hover { background: #0ff; color: #000; box-shadow: 0 0 50px #0ff; }
  </style>
</head>
<body>

<div id="ui">
  <div class="stat">SCORE: <span id="scoreVal">0</span></div>
  <div class="stat">BEST: <span id="bestVal">0</span></div>
</div>

<div id="overlay">
  <h1 id="title">CYBER DRIFT</h1>
  <p style="color: #f0f;">Sobreviva à rodovia de néon</p>
  <button class="btn" onclick="startGame()">INICIAR ENGINE</button>
  <p style="color: #666; margin-top: 20px;">Use o MOUSE ou TOQUE para deslizar</p>
</div>

<canvas id="canvas"></canvas>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const scoreDisplay = document.getElementById('scoreVal');
const bestDisplay = document.getElementById('bestVal');
const overlay = document.getElementById('overlay');

let w, h, player, obstacles, particles, score, gameActive, speed, frame;

function resize() {
  w = canvas.width = window.innerWidth;
  h = canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

// Gerenciamento de recorde
let bestScore = localStorage.getItem('bestDrift') || 0;
bestDisplay.innerText = bestScore;

function startGame() {
  player = { x: w/2, targetX: w/2, y: h * 0.8, size: 20 };
  obstacles = [];
  particles = [];
  score = 0;
  speed = 8;
  frame = 0;
  gameActive = true;
  overlay.style.display = 'none';
  animate();
}

// Controles
window.addEventListener('mousemove', (e) => player.targetX = e.clientX);
window.addEventListener('touchmove', (e) => {
  player.targetX = e.touches[0].clientX;
  e.preventDefault();
}, {passive: false});

class Obstacle {
  constructor() {
    this.lane = Math.floor(Math.random() * 5) - 2; // -2 a 2
    this.z = 1000; // Distância inicial
    this.w = 150;
    this.h = 40;
    this.color = Math.random() > 0.5 ? '#0ff' : '#f0f';
  }

  update() {
    this.z -= speed;
  }

  draw() {
    const scale = 400 / (this.z + 1);
    const x = w/2 + (this.lane * 200 * scale);
    const y = h/2 + (200 * scale);
    const drawW = this.w * scale;
    const drawH = this.h * scale;

    ctx.fillStyle = this.color;
    ctx.shadowBlur = 20 * scale;
    ctx.shadowColor = this.color;
    ctx.fillRect(x - drawW/2, y - drawH/2, drawW, drawH);
    
    // Detecção de colisão (quando z está perto de 0)
    if (this.z < 20 && this.z > -20) {
      const playerPos = (player.x - w/2) / (200 * (400 / 21)); // Normalização aproximada
      const obsLanePos = this.lane;
      
      // Checagem simplificada de proximidade
      const dist = Math.abs((player.x - x));
      if (dist < drawW/2 + player.size) {
        endGame();
      }
    }
  }
}

function drawGrid() {
  ctx.strokeStyle = '#044';
  ctx.lineWidth = 1;
  ctx.shadowBlur = 0;
  
  const offset = (frame * speed) % 100;
  
  // Linhas horizontais (profundidade)
  for (let i = 0; i < 20; i++) {
    const z = i * 50 - offset;
    if (z <= 0) continue;
    const scale = 400 / z;
    const y = h/2 + (200 * scale);
    ctx.beginPath();
    ctx.moveTo(0, y);
    ctx.lineTo(w, y);
    ctx.stroke();
  }

  // Linhas verticais (perspectiva)
  for (let i = -10; i <= 10; i++) {
    const xStart = w/2;
    const yStart = h/2;
    const xEnd = w/2 + i * 500;
    const yEnd = h;
    ctx.beginPath();
    ctx.moveTo(xStart, yStart);
    ctx.lineTo(xEnd, yEnd);
    ctx.stroke();
  }
}

function endGame() {
  gameActive = false;
  overlay.style.display = 'flex';
  document.getElementById('title').innerText = "WASTED";
  document.getElementById('title').style.color = "#f05";
  if (score > bestScore) {
    bestScore = Math.floor(score);
    localStorage.setItem('bestDrift', bestScore);
    bestDisplay.innerText = bestScore;
  }
}

function animate() {
  if (!gameActive) return;

  // Background
  ctx.fillStyle = '#000';
  ctx.fillRect(0, 0, w, h);

  drawGrid();

  // Movimento Suave do Jogador
  player.x += (player.targetX - player.x) * 0.15;

  // Gerar Obstáculos
  if (frame % 30 === 0) obstacles.push(new Obstacle());

  // Atualizar Obstáculos
  obstacles.forEach((obs, i) => {
    obs.update();
    obs.draw();
    if (obs.z < -100) {
      obstacles.splice(i, 1);
      score += 10;
    }
  });

  // Desenhar Jogador (Nave)
  ctx.shadowBlur = 25;
  ctx.shadowColor = '#0ff';
  ctx.fillStyle = '#fff';
  ctx.beginPath();
  ctx.moveTo(player.x, player.y - 20);
  ctx.lineTo(player.x - 25, player.y + 20);
  ctx.lineTo(player.x + 25, player.y + 20);
  ctx.closePath();
  ctx.fill();

  // HUD
  score += 0.1;
  scoreDisplay.innerText = Math.floor(score);
  speed += 0.002;
  frame++;

  requestAnimationFrame(animate);
}

</script>
</body>
</html>
